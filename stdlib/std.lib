(define nil '())

(define nil? (lambda (x) (= nil x)))

(define identity (lambda (x) x))

(define list (lambda (... args) args))

(define apply (macro (fn arr) `(~fn ~@arr)))

(define cond (macro (x ... rest)
  `(if ~(car x)
       ~(car (cdr x))
        (if ~(nil? rest)
          ()
          (cond ~@rest)))))

(define and
  (macro (x ... args)
    (if (nil? args)
      x
      `(if ~x (and ~@args) false))))

(define or
  (macro (x ... args)
    (if (nil? args)
      x
      `(if ~x true (or ~@args)))))

(define has-nil?
  (lambda (arr)
  (if (nil? arr)
    false
    (or (nil? (car arr)) (recur (cdr arr))))))

(define car'
  (lambda (arrs)
  (if (nil? arrs)
    nil
    (cons
      (car (car arrs))
      (recur (cdr arrs))))))

(define foldr (lambda (fn base lst)
  (if (nil? lst)
    base
    (fn (recur fn base (cdr lst)) (car lst)))))

(define foldl (lambda (fn base lst)
  (if (nil? lst)
    base
    (recur fn
      (fn base (car lst))
      (cdr lst)))))

(define reverse
  (lambda (l) (foldl (lambda (acc v) (cons v acc)) nil l)))

(define concat (lambda (l1 l2)
  (reverse (foldl (lambda (acc v) (cons v acc)) (reverse l1) l2))))

(define filter (lambda (pred arr)
  (foldr (lambda (acc v)
    (if (pred v)
      (cons v acc)
      acc
    )
  ) '() arr)))

(define zero?
  (lambda (expr)
    (= 0 expr)))

(define not
  (lambda (expr)
    (if expr false true)))

(define second
  (lambda (x)
    (car (cdr x))))

(define contain? (lambda (fn key arr)
   (foldr (lambda (acc v) (or acc (= key (fn v)))) false arr)))

(define len (lambda (coll)
  (foldr (lambda (acc _) (+ acc 1)) 0 coll)))

(define dedupe (lambda (arr) (foldr (lambda (acc x) (if (contain? identity x acc) acc (cons x acc))) '() arr)))

(define nth
  (lambda (lst n)
    (if (zero? n)
      (car lst)
      (recur (cdr lst) (- n 1)))))

(define remove-nth
  (lambda (list n)
    (if (zero? n)
      (cdr list)
      (cons (car list) (recur (cdr list) (- n 1))))))

(define last (lambda (lst)
  (cond
    ((nil? lst) lst)
    ((nil? (cdr lst)) (car lst))
    (true (recur (cdr lst))))))

(define do (lambda (... args) (last args)))

(define range (lambda (fst ... args)
  (if (nil? args)
    (range 0 fst)
    (if (equal? fst (car args))
      nil
      (cons fst (recur (+ 1 fst) (car args)))))))
